import {
  useState,
  useLayoutEffect,
  RefObject,
  useEffect,
  useContext,
} from "react"
import Quaternion from "quaternion"
import { mulVQ } from "@thi.ng/matrices"
import Lore from "lore-engine"

import { DimensionsContext } from "../../context"
import useSolidContext from "./useSolidContext"

interface UseRotationConfig {
  fps: number
  secondsPerRotation: number
  fullRotation: number
  onTick?: (event: { tick: number; maxTicks: number }) => void
  x3dRef: RefObject<any>
  label: string
}

const a1VectorOfRotation = [0, 0, 0]
const a2ViewVector = [0, 0, 3.5]

const r1 = [a1VectorOfRotation[0], a2ViewVector[0]]
const r2 = [a1VectorOfRotation[1], a2ViewVector[1]]
const r3 = [a1VectorOfRotation[2], a2ViewVector[2]]

const acosd = (val: number) => Math.acos(Math.cos(val))

const cubeRotations = [
  // Those are angles for rotation for each axis
  // So for face #1 rotation would look something like
  // rotationX="1 0 0 0.478407346410207"
  // rotationY="0 1 0 -0.901592653589793"
  // rotationZ="0 0 1 0.028407346410207"
  // [0, 0, 0],
  [Math.PI / 4, -Math.PI / 5, 0], // #1
  [Math.PI / 4, Math.PI / 5, -Math.PI / 3], // #2
  [-Math.PI / 4, Math.PI / 5, -Math.PI / 3], // #3
  [(-Math.PI * 3) / 4, Math.PI / 5, -Math.PI / 3], // #4
  [(-Math.PI * 3) / 4, -Math.PI / 5, 0], // #6
  [(Math.PI * 3) / 4, -Math.PI / 5, 0], // #5
]

const rotations = cubeRotations

const getRotation = (start: number, end: number, percent: number) => {
  const diff = start - end
  const finalDiff =
    Math.abs(diff) > Math.PI
      ? -1 * (diff + (diff > 0 ? -Math.PI : Math.PI))
      : diff
  return start - finalDiff * percent
}

export default function useRotation({
  fps,
  secondsPerRotation,
  fullRotation,
  onTick,
  x3dRef,
  label,
}: UseRotationConfig) {
  const { goNext } = useContext(DimensionsContext)
  const {
    solidData: { edges, faces, vertices },
    solidData,
  } = useSolidContext()
  console.log(
    "%cMyProject%cline:63%csolidData",
    "color:#fff;background:#ee6f57;padding:3px;border-radius:2px",
    "color:#fff;background:#1f3c88;padding:3px;border-radius:2px",
    "color:#fff;background:rgb(131, 175, 155);padding:3px;border-radius:2px",
    solidData,
  )

  const maxTicks = fps * secondsPerRotation * rotations.length
  const [tick, setTick] = useState(0)
  const [isLoaded, setIsLoaded] = useState(false)

  const fixedTick = tick >= maxTicks ? maxTicks - 1 : tick

  const fromFace = Math.floor(fixedTick / (fps * secondsPerRotation))
  const toFace = fromFace + 1 === rotations.length ? 0 : fromFace + 1

  const percent =
    (fixedTick - fromFace * fps * secondsPerRotation) /
    (fps * secondsPerRotation)

  const rotationX = getRotation(
    rotations[fromFace][0],
    rotations[toFace][0],
    percent,
  )

  const rotationY = getRotation(
    rotations[fromFace][1],
    rotations[toFace][1],
    percent,
  )

  const rotationZ = getRotation(
    rotations[fromFace][2],
    rotations[toFace][2],
    percent,
  )
  ////////////////////////////////////////////////////////////////////////////////////////////////////////

  const face = 0

  const expectedX = cubeRotations[face][0]
  const expectedY = cubeRotations[face][1]
  const expectedZ = cubeRotations[face][2]
  console.log(
    `expectedX[${expectedX}] expectedY[${expectedY}] expectedZ[${expectedZ}]`,
  )

  // alpha = acosd(a2(1)/sqrt(a2(1)^2+a2(2)^2+a2(3)^2));
  // beta  = acosd(a2(2)/sqrt(a2(1)^2+a2(2)^2+a2(3)^2));
  // gamma = acosd(a2(3)/sqrt(a2(1)^2+a2(2)^2+a2(3)^2));
  const alpha = Math.acos(
    a2ViewVector[0] /
      Math.sqrt(
        Math.pow(a2ViewVector[0], 2) +
          Math.pow(a2ViewVector[1], 2) +
          Math.pow(a2ViewVector[2], 2),
      ),
  )
  const beta = Math.acos(
    a2ViewVector[1] /
      Math.sqrt(
        Math.pow(a2ViewVector[0], 2) +
          Math.pow(a2ViewVector[1], 2) +
          Math.pow(a2ViewVector[2], 2),
      ),
  )
  const gamma = Math.acos(
    a2ViewVector[2] /
      Math.sqrt(
        Math.pow(a2ViewVector[0], 2) +
          Math.pow(a2ViewVector[1], 2) +
          Math.pow(a2ViewVector[2], 2),
      ),
  )
  console.log(`alpha[${alpha}] beta[${beta}] gamma[${gamma}]`)

  // ab = ((A11(1)+A12(1)+A15(1)+A13(1))/4); %divide by n
  // ac = ((A11(2)+A12(2)+A15(2)+A13(2))/4);
  // ad = ((A11(3)+A12(3)+A15(3)+A13(3))/4);
  const ab =
    faces[face]
      .map((vertexIndex) => vertices[vertexIndex][0])
      .reduce((acc, cur) => acc + cur, 0) / faces[face].length
  const ac =
    faces[face]
      .map((vertexIndex) => vertices[vertexIndex][1])
      .reduce((acc, cur) => acc + cur, 0) / faces[face].length
  const ad =
    faces[face]
      .map((vertexIndex) => vertices[vertexIndex][2])
      .reduce((acc, cur) => acc + cur, 0) / faces[face].length
  console.log(`ab[${ab}] ac[${ac}] ad[${ad}]`)

  // %Face angles
  // ANGLE1 = acosd(ab/sqrt(ab^2+ac^2+ad^2));
  // ANGLE2 = acosd(ac/sqrt(ab^2+ac^2+ad^2));
  // ANGLE3 = acosd(ad/sqrt(ab^2+ac^2+ad^2));
  const ANGLE1 = Math.acos(
    ab / Math.sqrt(Math.pow(ab, 2) + Math.pow(ac, 2) + Math.pow(ad, 2)),
  )
  const ANGLE2 = Math.acos(
    ac / Math.sqrt(Math.pow(ac, 2) + Math.pow(ac, 2) + Math.pow(ad, 2)),
  )
  const ANGLE3 = Math.acos(
    ad / Math.sqrt(Math.pow(ad, 2) + Math.pow(ac, 2) + Math.pow(ad, 2)),
  )
  console.log(`ANGLE1[${ANGLE1}] ANGLE2[${ANGLE2}] ANGLE3[${ANGLE3}]`)

  // ANGLEX = 0.5*(alpha-ANGLE1)*0.017453292;    %% ANGLEX=0.5*(ANGLEX)
  // ANGLEY = 0.5*(beta-ANGLE2)*0.017453292;     %% ANGLEY=0.5*(ANGLEY)
  // ANGLEZ = 0.5*(gamma-ANGLE3)*0.017453292;    %% ANGLEZ=0.5*(ANGLEZ)
  const ANGLEX = 0.5 * (alpha - ANGLE1) // * 0.017453292
  const ANGLEY = 0.5 * (beta - ANGLE2) // * 0.017453292
  const ANGLEZ = 0.5 * (gamma - ANGLE3) // * 0.017453292
  console.log(`ANGLEX[${ANGLEX}] ANGLEY[${ANGLEY}] ANGLEZ[${ANGLEZ}]`)

  // cosx = cos(ANGLEX); %% First calculate the angle of your custom input angle cos sin for all 3 angle in "RADIANS"
  // cosy = cos(ANGLEY);
  // cosz = cos(ANGLEZ);
  // sinx = sin(ANGLEX);
  // siny = sin(ANGLEY);
  // sinz = sin(ANGLEZ);
  const cosx = Math.cos(ANGLEX)
  const cosy = Math.cos(ANGLEY)
  const cosz = Math.cos(ANGLEZ)
  const sinx = Math.sin(ANGLEX)
  const siny = Math.sin(ANGLEY)
  const sinz = Math.sin(ANGLEZ)

  // Finalw = cosx*cosy*cosz-sinx*siny*sinz;
  // Finalx = sinx*siny*cosz+cosx*cosy*sinz;
  // Finaly = sinx*cosy*cosz+cosx*siny*sinz;   %% USE THIS FUNCTION FOR WXYZ PARAMETERS FOR YOUR REQUIRED QUATERNION FOR ROTATION
  // Finalz = cosx*siny*cosz-sinx*cosy*sinz;
  const Finalw = cosx * cosy * cosz - sinx * siny * sinz
  const Finalx = sinx * siny * cosz + cosx * cosy * sinz
  const Finaly = sinx * cosy * cosz + cosx * siny * sinz
  const Finalz = cosx * siny * cosz - sinx * cosy * sinz
  console.log(
    `Finalw[${Finalw}] Finalx[${Finalx}] Finaly[${Finaly}] Finalz[${Finalz}]`,
  )

  // const quaternion = new Quaternion({
  //   w: Finalw,
  //   x: Finalx,
  //   y: Finaly,
  //   z: Finalz,
  // })
  // const quaternionConjugated = quaternion.conjugate()
  // console.log(
  //   "%cMyProject%cline:219%cquaternionConjugated",
  //   "color:#fff;background:#ee6f57;padding:3px;border-radius:2px",
  //   "color:#fff;background:#1f3c88;padding:3px;border-radius:2px",
  //   "color:#fff;background:rgb(248, 214, 110);padding:3px;border-radius:2px",
  //   quaternionConjugated,
  // )
  // console.log(
  //   `quaternion[${quaternion}] quaternionConjugated[${quaternionConjugated}]`,
  // )

  // const res: number[] = []
  // mulVQ(res, [Finalx, Finaly, Finalz, Finalw], [0, 0, 1.224745])
  // console.log(res)

  // const quaternion = new Lore.Math.Quaternion(Finalx, Finaly, Finalz, Finalw)

  // const vertexQuaternion = new Lore.Math.Quaternion(0, 0, 1.224745, 0)

  // const multiplyQuaternionAndVertex = Lore.Math.Quaternion.multiply(
  //   quaternion,
  //   vertexQuaternion,
  // )

  // const conjugatedQuaternion = Lore.Math.Quaternion.conjugate(quaternion)

  // const result = Lore.Math.Quaternion.multiply(
  //   multiplyQuaternionAndVertex,
  //   conjugatedQuaternion,
  // )

  // console.log(
  //   `quaternion[${quaternion}]\n\nvertexQuaternion[${vertexQuaternion}]\n\nmultiplyQuaternionAndVertex[${multiplyQuaternionAndVertex}]\n\nconjugatedQuaternion[${conjugatedQuaternion}]\n\nresult[${result}]`,
  // )

  const mult = (q: number[], r: number[]) => [
    r[0] * q[0] - r[1] * q[1] - r[2] * q[2] - r[3] * q[3],
    r[0] * q[1] + r[1] * q[0] - r[2] * q[3] + r[3] * q[2],
    r[0] * q[2] + r[1] * q[3] + r[2] * q[0] - r[3] * q[1],
    r[0] * q[3] - r[1] * q[2] + r[2] * q[1] + r[3] * q[0],
  ]

  const rotateVector = (point: number[], q: number[]) => {
    const r = [0, ...point]
    const qConj = [q[0], -1 * q[1], -1 * q[2], -1 * q[3]]
    return mult(mult(q, r), qConj).slice(1)
  }

  // console.log(rotateVector([0, 0, 1.224745], [Finalw, Finalx, Finaly, Finalz]))

  ////////////////////////

  const V0 = [ab, ac, ad]

  const V1 = [0, 0, 3]

  const initialQuaternion = Lore.Math.Quaternion.normalize(
    new Lore.Math.Quaternion(V0[0], V0[1], V0[2], 0),
  )

  const finalQuaternion = Lore.Math.Quaternion.normalize(
    new Lore.Math.Quaternion(V1[0], V1[1], V1[2], 0),
  )

  const delta = 1

  const V0Q = new Lore.Math.Quaternion(V0[0], V0[1], V0[2], 0)

  // console.log(
  //   "%cMyProject%cline:279%cV0",
  //   "color:#fff;background:#ee6f57;padding:3px;border-radius:2px",
  //   "color:#fff;background:#1f3c88;padding:3px;border-radius:2px",
  //   "color:#fff;background:rgb(131, 175, 155);padding:3px;border-radius:2px",
  //   V0,
  // )
  const angle = 0.8

  const rotationQuaternion = new Lore.Math.Quaternion(
    Math.sin(angle / 2) * V1[0],
    Math.sin(angle / 2) * V1[1],
    Math.sin(angle / 2) * V1[2],
    Math.cos(angle / 2),
  )
  const normalizedRotationQuaternion = Lore.Math.Quaternion.normalize(
    rotationQuaternion,
  )

  const Qxyz = mult([0, ...V1], [0, ...V0])

  const a2L = Math.sqrt(
    Math.pow(V1[0], 2) + Math.pow(V1[1], 2) + Math.pow(V1[2], 2),
  )

  const V0L = Math.sqrt(
    Math.pow(V0[0], 2) + Math.pow(V0[1], 2) + Math.pow(V0[2], 2),
  )

  const a2LQ = new Lore.Math.Quaternion(V1[0], V1[1], V1[2], 0)

  const dot =
    V0Q.components[0] * V1[0] +
    V0Q.components[1] * V1[1] +
    V0Q.components[2] * V1[2]

  const Qw = Math.sqrt(Math.pow(a2L, 2) * Math.pow(V0L, 2)) + dot

  const q = new Lore.Math.Quaternion(Qxyz[1], Qxyz[2], Qxyz[3], Qw)
  // console.log(`${q}`)

  // Normalize
  const normalizedQuaternion = Lore.Math.Quaternion.normalize(q)
  const multiplification = mult(
    [
      normalizedQuaternion.components[3],
      normalizedQuaternion.components[0],
      normalizedQuaternion.components[1],
      normalizedQuaternion.components[2],
    ],
    [
      normalizedRotationQuaternion.components[3],
      normalizedRotationQuaternion.components[0],
      normalizedRotationQuaternion.components[1],
      normalizedRotationQuaternion.components[2],
    ],
  )

  const afterRotation = new Lore.Math.Quaternion(
    multiplification[1],
    multiplification[2],
    multiplification[3],
    multiplification[0],
  )

  const n = Lore.Math.Quaternion.slerp(initialQuaternion, afterRotation, delta)
  // console.log(`${n}`)
  // LAST PART

  const sinrCosp =
    2 * (n.components[3] * n.components[0] + n.components[1] * n.components[2])
  const cosrCosp =
    1 -
    2 * (n.components[0] * n.components[0] + n.components[1] * n.components[1])
  const outputX = Math.atan2(sinrCosp, cosrCosp)

  const sinp =
    2 * (n.components[3] * n.components[1] - n.components[2] * n.components[0])
  const outputY =
    Math.abs(sinp) >= 1
      ? (Math.PI / 2) * (sinp >= 0 ? +1 : -1)
      : Math.asin(sinp)

  const sinyCosp =
    2 * (n.components[3] * n.components[2] + n.components[0] * n.components[1])
  const cosyCosp =
    1 -
    2 * (n.components[1] * n.components[1] + n.components[2] * n.components[2])
  const outputZ = Math.atan2(sinyCosp, cosyCosp)

  console.log(`outputX[${outputX}] outputY[${outputY}] outputZ[${outputZ}]`)

  const mulHam = (q1: any, q2: any) => {
    const w1 = q1.components[3]
    const x1 = q1.components[0]
    const y1 = q1.components[1]
    const z1 = q1.components[2]

    const w2 = q2.components[3]
    const x2 = q2.components[0]
    const y2 = q2.components[1]
    const z2 = q2.components[2]

    return new Lore.Math.Quaternion(
      w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2,
      w1 * y2 + y1 * w2 + z1 * x2 - x1 * z2,
      w1 * z2 + z1 * w2 + x1 * y2 - y1 * x2,
      w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2,
    )
  }

  console.log(`final quaternion ${n}`)

  const newCoords = vertices.map((vertex) => {
    const vertexQuaternion = new Lore.Math.Quaternion(
      vertex[0],
      vertex[1],
      vertex[2],
      0,
    )

    // return rotateVector(vertex, [n.getW(), n.getX(), n.getY(), n.getZ()])

    // Conjugate
    const conjugatedQuaternion = Lore.Math.Quaternion.conjugate(n)

    // Multiply vertex and quaternion
    const multiplyQuaternionAndVertex = mulHam(
      vertexQuaternion, // Vertex
      n, // Norm
    )
    // console.log(`${multiplyQuaternionAndVertex}`)

    // Multiply
    const result = mulHam(conjugatedQuaternion, multiplyQuaternionAndVertex)
    return [result.components[0], result.components[1], result.components[2]]
  })
  console.log(JSON.stringify(newCoords))

  ////////////////////////////////////////////////////////////////////////////////////////////////////////

  useLayoutEffect(() => {
    if (isLoaded) {
      if (tick < maxTicks) {
        setTimeout(() => {
          if (onTick) {
            onTick({ tick, maxTicks })
          }
          setTick((t) => t + 1)
        }, 1000 / fps)
      } else {
        goNext()
      }
    } else {
      setTimeout(() => {
        if (x3dRef.current && x3dRef.current.runtime) {
          // x3dRef.current.runtime.showAll()
          // x3dRef.current.runtime.fitObject(
          //   document.getElementById("cube-face-0"),
          // )
          setTimeout(() => {
            // setIsLoaded(true)
          }, 2000)
        }
      }, 1000)
    }
  }, [
    setTick,
    tick,
    isLoaded,
    setIsLoaded,
    maxTicks,
    onTick,
    fps,
    x3dRef,
    goNext,
  ])

  useEffect(() => {
    setIsLoaded(false)
    setTick(0)
  }, [label])

  return {
    n,
    rotationX: outputX,
    rotationY: outputY,
    rotationZ: outputZ,
    // rotationX,
    // rotationY,
    // rotationZ,
    // rotationX: rotations[0][0],
    // rotationY: rotations[0][1],
    // rotationZ: rotations[0][2],
  }
}
